name: Update News Headlines with Fallacy Analysis

on:
  workflow_dispatch: # Allow manual triggering
  # Comment for github

permissions:
  contents: write

jobs:
  update-headlines:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Fetch, analyze, and save headlines
        env:
          GNEWS_API_KEY: ${{ secrets.GNEWS_API_KEY }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          cat <<'EOL' > fetch-analyze.js
          const https = require('https');
          const fs = require('fs');

          const GNEWS_API_KEY = process.env.GNEWS_API_KEY;
          const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
          
          // Configuration for pagination
          const ARTICLES_PER_REQUEST = 10;
          const TOTAL_REQUESTS = 4;
          const TOTAL_ARTICLES = ARTICLES_PER_REQUEST * TOTAL_REQUESTS; // 40 total

          function buildGNewsUrl(page, articlesPerPage) {
            return `https://gnews.io/api/v4/search?q=news&lang=en&country=us&max=${articlesPerPage}&page=${page}&apikey=${GNEWS_API_KEY}`;
          }

          function makeRequest(url, options = {}) {
            return new Promise((resolve, reject) => {
              const req = https.request(url, options, (res) => {
                let data = '';
                res.on('data', (chunk) => (data += chunk));
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (error) {
                    resolve(data); // Return raw data if not JSON
                  }
                });
              });
              req.on('error', reject);
              if (options.body) {
                req.write(options.body);
              }
              req.end();
            });
          }

          async function fetchAllArticles() {
            const allArticles = [];
            
            console.log(`Fetching ${TOTAL_ARTICLES} articles across ${TOTAL_REQUESTS} API calls...`);
            
            for (let page = 1; page <= TOTAL_REQUESTS; page++) {
              console.log(`Fetching page ${page}/${TOTAL_REQUESTS} (${ARTICLES_PER_REQUEST} articles)...`);
              
              const apiUrl = buildGNewsUrl(page, ARTICLES_PER_REQUEST);
              
              try {
                const newsData = await makeRequest(apiUrl);
                
                if (!newsData.articles || newsData.articles.length === 0) {
                  console.warn(`No articles found in page ${page}:`, newsData);
                  continue;
                }
                
                console.log(`Page ${page}: Retrieved ${newsData.articles.length} articles`);
                allArticles.push(...newsData.articles);
                
                // Add delay between API calls to respect rate limits
                if (page < TOTAL_REQUESTS) {
                  console.log('Waiting 2 seconds before next API call...');
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
              } catch (error) {
                console.error(`Error fetching page ${page}:`, error.message);
                // Continue with other pages even if one fails
              }
            }
            
            console.log(`Total articles fetched: ${allArticles.length}`);
            return allArticles;
          }

          async function analyzeHeadline(headline, fallacyDefinitions) {
            const fallacyList = Object.keys(fallacyDefinitions).join('", "');
            const prompt = `Analyze the following news headline for logical fallacies: "${headline}"

          Please respond with a JSON object in this exact format:
          {
            "containsFallacy": true/false,
            "fallacy": "type of fallacy if found, or null",
            "explanation": "A brief explanation of why it is a fallacy, or null if no fallacy is found."
          }

          IMPORTANT: If you identify a fallacy, the value for the "fallacy" key MUST be an exact match from the following list: "${fallacyList}".

          If the headline does not contain a fallacy from that specific list, you MUST set "containsFallacy" to false and "fallacy" to null. Do not identify fallacies that are not on this list.
          Only return the JSON object and nothing else.`;

            const requestBody = JSON.stringify({
              model: 'mistralai/mistral-small-3.2-24b-instruct:free',
              messages: [{ role: 'user', content: prompt }],
              temperature: 0.3,
              max_tokens: 200,
            });

            const options = {
              method: 'POST',
              headers: {
                Authorization: `Bearer ${OPENROUTER_API_KEY}`,
                'Content-Type': 'application/json',
                'HTTP-Referer': 'https://github.com/Alviz-git/Media-Litteracy',
                'X-Title': 'Media Literacy Fallacy Detection',
              },
              body: requestBody,
            };

            try {
              const response = await makeRequest('https://openrouter.ai/api/v1/chat/completions', options);

              if (response.choices && response.choices[0] && response.choices[0].message) {
                const content = response.choices[0].message.content.trim();
                try {
                  const jsonMatch = content.match(/\{[\s\S]*\}/);
                  if (jsonMatch) {
                    const analysis = JSON.parse(jsonMatch[0]);
                    if (analysis.fallacy && !Object.keys(fallacyDefinitions).includes(analysis.fallacy)) {
                      console.log(`Warning: AI returned a fallacy "${analysis.fallacy}" not in the defined list. Overriding.`);
                      analysis.containsFallacy = false;
                      analysis.fallacy = null;
                    }
                    return analysis;
                  }
                  throw new Error('No JSON object found in response');
                } catch (parseError) {
                  console.error(`Failed to parse analysis for "${headline}":`, content, parseError);
                  return { containsFallacy: false, fallacy: null, explanation: `Parsing failed: ${parseError.message}` };
                }
              } else {
                console.error(`No valid choices in API response for "${headline}"`);
                return { containsFallacy: false, fallacy: null, explanation: 'Invalid API response structure.' };
              }
            } catch (error) {
              console.error(`Error analyzing "${headline}":`, error.message);
              return { containsFallacy: false, fallacy: null, explanation: error.message };
            }
          }

          async function main() {
            try {
              const fallacyDefinitions = JSON.parse(fs.readFileSync('data/fallacy-definitions.json', 'utf8'));
              
              // Fetch all articles using pagination
              const allArticles = await fetchAllArticles();
              
              if (allArticles.length === 0) {
                console.error('No articles found across all API calls');
                process.exit(1);
              }

              console.log(`Analyzing ${allArticles.length} headlines...`);
              const analyzedHeadlines = [];

              for (const [index, article] of allArticles.entries()) {
                console.log(`Analyzing headline ${index + 1}/${allArticles.length}: ${article.title}`);
                const analysis = await analyzeHeadline(article.title, fallacyDefinitions);

                // Normalize the article structure to match your required format
                const normalizedArticle = {
                  title: article.title,
                  description: article.description,
                  url: article.url,
                  source: typeof article.source === 'string' ? article.source : (article.source?.name || 'Unknown'),
                  publishedAt: article.publishedAt,
                  image: article.image,
                  containsFallacy: analysis.containsFallacy || false,
                  fallacy: analysis.fallacy || null,
                  explanation: analysis.explanation || null
                };

                analyzedHeadlines.push(normalizedArticle);

                // Add delay between analysis calls
                if (index < allArticles.length - 1) {
                  await new Promise((resolve) => setTimeout(resolve, 1000)); // 1s delay
                }
              }

              const fallacyHeadlines = analyzedHeadlines.filter((a) => a.containsFallacy);
              console.log(`Found ${fallacyHeadlines.length} headlines with fallacies out of ${analyzedHeadlines.length} total.`);

              // Load existing headlines if the file exists
              let existingData = { headlines: [] };
              const headlinesFilePath = 'data/headlines.json';
              
              if (fs.existsSync(headlinesFilePath)) {
                try {
                  existingData = JSON.parse(fs.readFileSync(headlinesFilePath, 'utf8'));
                  console.log(`Loaded ${existingData.headlines.length} existing headlines.`);
                } catch (error) {
                  console.warn('Could not parse existing headlines.json, starting fresh:', error.message);
                  existingData = { headlines: [] };
                }
              }

              // Filter out duplicates based on title and URL
              const existingUrls = new Set((existingData.headlines || []).map(h => h.url));
              const newFallacyHeadlines = fallacyHeadlines.filter(h => !existingUrls.has(h.url));
              
              console.log(`${newFallacyHeadlines.length} new unique headlines with fallacies to add.`);

              // Append new headlines to existing ones
              const allFallacyHeadlines = [...(existingData.headlines || []), ...newFallacyHeadlines];

              const output = {
                lastUpdated: new Date().toISOString(),
                totalAnalyzed: analyzedHeadlines.length,
                fallaciesFound: newFallacyHeadlines.length,
                totalFallacyHeadlines: allFallacyHeadlines.length,
                headlines: allFallacyHeadlines,
              };

              // Load existing all-headlines data
              let existingAllData = { headlines: [] };
              const allHeadlinesFilePath = 'data/all-headlines.json';
              
              if (fs.existsSync(allHeadlinesFilePath)) {
                try {
                  existingAllData = JSON.parse(fs.readFileSync(allHeadlinesFilePath, 'utf8'));
                  console.log(`Loaded ${existingAllData.headlines.length} existing all-headlines.`);
                } catch (error) {
                  console.warn('Could not parse existing all-headlines.json, starting fresh:', error.message);
                  existingAllData = { headlines: [] };
                }
              }

              // Filter out duplicates for all headlines
              const existingAllUrls = new Set((existingAllData.headlines || []).map(h => h.url));
              const newAllHeadlines = analyzedHeadlines.filter(h => !existingAllUrls.has(h.url));
              
              console.log(`${newAllHeadlines.length} new unique headlines (all) to add.`);

              // Append new headlines to existing ones
              const allHeadlines = [...(existingAllData.headlines || []), ...newAllHeadlines];

              const allOutput = {
                lastUpdated: new Date().toISOString(),
                totalAnalyzed: newAllHeadlines.length,
                totalHeadlines: allHeadlines.length,
                headlines: allHeadlines,
              };

              if (!fs.existsSync('data')) fs.mkdirSync('data');
              fs.writeFileSync('data/headlines.json', JSON.stringify(output, null, 2));
              fs.writeFileSync('data/all-headlines.json', JSON.stringify(allOutput, null, 2));
              console.log('Analysis complete. Files updated with new headlines appended.');
              
              // Summary
              console.log('\n=== SUMMARY ===');
              console.log(`Total API calls made: ${TOTAL_REQUESTS}`);
              console.log(`Articles per call: ${ARTICLES_PER_REQUEST}`);
              console.log(`Total articles fetched: ${allArticles.length}`);
              console.log(`Total articles analyzed: ${analyzedHeadlines.length}`);
              console.log(`Headlines with fallacies: ${fallacyHeadlines.length}`);
              console.log(`New unique fallacy headlines added: ${newFallacyHeadlines.length}`);
              
            } catch (error) {
              console.error('Error in main function:', error);
              process.exit(1);
            }
          }

          main();
          EOL
          node fetch-analyze.js

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/headlines.json data/all-headlines.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update news headlines with fallacy analysis - $(date)"
            git push
          fi
